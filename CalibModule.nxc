#ifndef __CALIB_MODULE__
#define __CALIB_MODULE__

// Includes only for testing purposes. Must be in this order in the main file
/*
#include "SensorModule.nxc"
#include "MotorUnit.nxc"
// #include "CalibModule.nxc"
*/

//******************************************************
// Calibration Module
//
// Authors: Alexander Strobl, Daniel Tatzel
//******************************************************

//******************************************************
// Declarations
//******************************************************

// Compass reference value used for calibration
short CU_TempCompassRef = -1;


/* Function: CU_CalibCompassValue
	- Matches the virtual direction and the real direction to get the difference between target state and actual state
	- Variables:
		- orientation: virtuel direction on the map
		- Offset: Difference between virtual and real direction
*/
unsigned short CU_CalibCompassValue( short orientation, short Offset );


/* Function: CU_GetAzimuth
	- Calculates the difference in degrees between target and actual state to change the direction of the robot
	- Needs the value of CU_CalibCompassValue( orientation, SU_InitCompassValue )
*/
short CU_GetAzimuth( short degree );


/* Function: CU_GetAzimuthPositive
	- Calculates the difference in degrees between target and actual state to change the direction of the robot
	- Needs the value of CU_CalibCompassValue( orientation, SU_InitCompassValue )
	- Returns olny postive numbers
*/
short CU_GetAzimuthPositive( short degree );


/* Function: CU_Measuring_front
	- Measures the distance to the next object to the front (only if in range)
	- Adjusts the Position of the robot according to the distance between the object and robot
*/
void CU_Measuring_front( byte FieldRange_front );


/* Function: CU_Measuring_rear
	- Measures the distance to the next object to the rear (only if in range)
	- Adjusts the Position of the robot according to the distance between the object and robot
*/
void CU_Measuring_rear( byte FieldRange_rear );


/* Function: CU_TurnToOrientation
	- Aligns the robot to the driving direction
*/
void CU_TurnToOrientation( short orientation );


/* Function: CU_Drift
	- Calculates if the robot drifted to the right or left after driving
*/
void CU_Drift( short orientation );


/* Function: CU_PosCalibration
	- Must be started from the control unit
	- Needs: actual x and y coordiante and orientation of the robot
	- Calls all other funtctions
	- Checks:
		- Deviation
		- Looks for the next obstacle to the front and rear (uses virtual map and actual position)
		- Corrects the alignment of the robot to the actual virtual orientation (on the map)
		- Measures distances
*/
int CU_PosCalibration( byte xpos, byte ypos, short orientation );


//******************************************************
// Defines
//******************************************************

// Should be adjusted, just first idea
#define CU_CriticalDistance 20


//******************************************************
// Definitions
//******************************************************



//******************************************************
// Functions and tasks
//******************************************************

task CU_CheckObstacle( )
{
	while ( true )
	{
		if ( CU_CriticalDistance >= SU_Values.iDistance_Front )
		{
			// Something went wrong throw stop event!!
			
			// Idea:
			// Check if it is an expected Wall. If not throw stop event. If expected than do nothing
			/* if ( Wall != expected )
			{
				throw stop event;
				call CU_Drift();
				search possible wall on map;
				tell MotorUNit how to adjust;
				delete stop event;
			}
			*/
		}
	}
}


unsigned short CU_CalibCompassValue( short orientation, short Offset )
{
	int help = orientation + Offset;

	if ( 360 <= help )
		help -= 360;

	if ( 0 > help )
		help += 360;

	return help;
}

short CU_GetAzimuthPositive( short degree )
{
	if ( degree < SU_Values.iCurrentDeg)
		return SU_Values.iCurrentDeg - degree;
	if ( degree > SU_Values.iCurrentDeg)
		return degree + SU_Values.iCurrentDeg;
}

short CU_GetAzimuth( short degree )
{
	short tmpdeg = degree - SU_Values.iCurrentDeg;

	if ( 180 < tmpdeg )
		tmpdeg -= 360;
		
	return tmpdeg;
}

void CU_Measuring_front( byte FieldRange_front )
{
		// Pruefen ob Hindernis in Reichweite ist
		if ( ( FieldRange_front * GLOBAL_1_SEKTOR ) >= SU_SONIC_RADIUS )
		{
			until(!MutexUSonic);
			SU_Values.iDistance_Front = SensorUS ( SU_SONIC_FRONT );

			
			// Verarbeitung Starten (Bedenken: Wird Rueckgabewert bedingt? Wenn ja, diese Funktion trennen, wegen Rueckgabewerte
			if ( SU_Values.iDistance_Front < ( FieldRange_front * GLOBAL_1_SEKTOR ) )
			{
				// Zu weit vorne 
				MU_drive_backward( ( ( FieldRange_front * GLOBAL_1_SEKTOR ) - SU_Values.iDistance_front ), false);
			}
			else if ( SU_Values.iDistance_Front > ( FieldRange_front * GLOBAL_1_SEKTOR ) )
			{
				// Zu weit hinten
				
				MU_drive_forward( ( SU_Values.iDistance_Front - ( FieldRange_front * GLOBAL_1_SEKTOR ) ), false);
			}
		}
}

void CU_Measuring_rear( byte FieldRange_rear)
{
		if ( ( FieldRange_rear * GLOBAL_1_SEKTOR ) >= SU_SONIC_RADIUS )
		{
			until(!MutexUSonic);
			SU_Values.iDistance_Back = SensorUS ( SU_SONIC_BACK );

			if ( SU_Values.iDistance_Back > ( FieldRange_rear * GLOBAL_1_SEKTOR ) )
			{
				// Zu weit vorne 
				MU_drive_backward( ( ( FieldRange_rear * GLOBAL_1_SEKTOR ) - SU_Values.iDistance_front ), false);
			}
			else if ( SU_Values.iDistance_Back < ( FieldRange_rear * GLOBAL_1_SEKTOR ) )
			{
				// Zu weit hinten
				MU_drive_forward( ( SU_Values.FieldRange_rear - ( FieldRange_rear * GLOBAL_1_SEKTOR ) ), false);
			}
		}
}

void CU_TurnToOrientation( short orientation )
{
		unsigned short degree = CU_CalibCompassValue( orientation, SU_InitCompassValue );

		if ( degree != SU_Values.iCurrentDeg )
		{
			short degreetoturn = CU_GetAzimuth( degree );

			MU_drehen_by_angle( degreetoturn );
		}
}

void CU_Drift( short orientation )
{
		if ( ( -1 != CU_TempCompassRef )  )
		{
			if ( 80 > CU_GetAzimuthPositive( CU_TempCompassRef ) )
			{
				short side = CU_GetAzimuth( CU_TempCompassRef ) * (  -1 );
				
				CU_TurnToOrientation( orientation );
				
				// Left
				if ( 0 > side )
				{
					// Do stuff and things
				
				}
				else if ( 0 < side )	// Right
				{
					// Do stuff and things
				
				}
			}
		}

}

int CU_PosCalibration( byte xpos, byte ypos, short orientation )
{
    byte tmpx = xpos;
	byte tmpy = ypos;
	byte FieldRange_front = 0;
	byte FieldRange_rear = 0;

		CU_Drift( orientation );
		
		if ( 0 == orientation || 180 == orientation ) // Nord & Sued Ausrichtung
        {
            while ( true )
            {
				tmpy--;
                if ( g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * tmpy + xpos] == '#')
				{
					tmpy++;
					if ( 0 == orientation )
					{
						FieldRange_front = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
					}
					else if ( 180 == orientation )
					{
						FieldRange_rear = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
					}
                    break;
				}
            }

            while ( true )
            {
				tmpy++;
                if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * tmpy + xpos] )
				{
					tmpy--;
					if ( 0 == orientation )
					{
						FieldRange_rear = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
					}
					else if ( 180 == orientation )
					{
						FieldRange_front = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
					}
                    break;
				}
            }
        }

        if ( 90 == orientation || 270 == orientation ) // Ost & West Ausrichtung
        {
            while ( true )
            {
				tmpx--;
                if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * ypos + tmpx] )
				{
					xpos++;
					if ( 90 == orientation )
					{
						FieldRange_rear = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
					}
					else if (270 == orientation )
					{
						FieldRange_front = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
					}
                    break;
				}
				
            }

            while ( true )
            {
				tmpx++;
                if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * ypos + tmpx] )
				{
					xpos--;
					if ( 90 == orientation )
					{
						FieldRange_front = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
					}
					else if ( 270 == orientation )
					{
						FieldRange_rear = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
					}
                    break;
				}
				
            }

        }


		CU_TurnToOrientation( orientation );

		CU_Measuring_front( FieldRange_front );
		CU_Measuring_rear( FieldRange_rear );
		
		CU_TempCompassRef = SU_Values.iCurrentDeg;
}

#endif /* __CALIB_MODULE__ */
