#ifndef __CALIB_MODULE__
#define __CALIB_MODULE__

// Includes only for testing purposes. Must be in this order in the main file

#include "SensorModule.nxc"
#include "MotorUnit.nxc"
// #include "CalibModule.nxc"

//######################################################
// Calibration Module
//
// Authors: Alexander Strobl, Daniel Tatzel
//######################################################

//######################################################
// Declarations
//######################################################

// Compass reference value used for calibration
short CU_TempCompassRef = -1;
byte flag = 0;
      /*

/* Function: CU_CheckObstacle
	- Checks for obstacles in the path of the robot
	- Throws a stop event if an unexpected obstacle appears
*/
void CU_CheckObstacle( byte xpos, byte ypos, short orientation );


/* Function: CU_CalibCompassValue
	- Matches the virtual direction and the real direction to get the difference between target state and actual state
	- Variables:
		- orientation: virtuel direction on the map
		- Offset: Difference between virtual and real direction
*/
unsigned short CU_CalibCompassValue( short orientation, short Offset );


/* Function: CU_GetAzimuth
	- Calculates the difference in degrees between target and actual state to change the direction of the robot
	- Needs the value of CU_CalibCompassValue( orientation, SU_InitCompassValue )
*/
short CU_GetAzimuth( short degree );


/* Function: CU_GetAzimuthPositve
	- Calculates the difference in degrees between target and actual state to change the direction of the robot
	- Needs the value of CU_CalibCompassValue( orientation, SU_InitCompassValue )
	- Returns olny postive numbers
*/
short CU_GetAzimuthPositive( short degree );


/* Function: CU_Measuring_front
	- Measures the distance to the next object to the front (only if in range)
	- Adjusts the Position of the robot according to the distance between the object and robot
*/
void CU_Measuring_front( byte FieldRange_front );


/* Function: CU_Measuring_rear
	- Measures the distance to the next object to the rear (only if in range)
	- Adjusts the Position of the robot according to the distance between the object and robot
*/
void CU_Measuring_rear( byte FieldRange_rear );


/* Function: CU_TurnToOrientation
	- Aligns the robot to the driving direction
*/
void CU_TurnToOrientation( short orientation );


/* Function: CU_Drift
	- Calculates if the robot drifted to the right or left after driving
*/
void CU_Drift( short orientation, byte xpos, byte ypos );


/* Function: CU_PosCalibration
	- Must be started from the control unit
	- Needs: actual x and y coordiante and orientation of the robot
	- Calls all other funtctions
	- Checks:
		- Deviation
		- Looks for the next obstacle to the front and rear (uses virtual map and actual position)
		- Corrects the alignment of the robot to the actual virtual orientation (on the map)
		- Measures distances
*/
int CU_PosCalibration( byte xpos, byte ypos, short orientation );


//######################################################
// Defines
//######################################################

// Should be adjusted, just first idea
#define CU_CriticalDistance 10

//######################################################
// Functions and tasks
//######################################################

// Idea: Check Sensor, throw event, ControlUnit executes function?
void CU_CheckObstacle( byte xpos, byte ypos, short orientation )
{
	byte FieldRange_front = 0;
	
	while ( true )
	{
		//aktuelle (theoretische) position abrufen
	
		SU_Values.iDistance_Front = SensorUS ( SU_SONIC_FRONT );		
			
		if ( CU_CriticalDistance >= SU_Values.iDistance_Front )
		{
			/*
			// Something went wrong throw stop event!!
			if ( 0 == orientation || 180 == orientation ) // Nord & Sued Ausrichtung
			{
				while ( true )
				{
					tmpy--;
					if ( g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * tmpy + xpos] == '#')
					{
						tmpy++;
						if ( 0 == orientation )
						{
							FieldRange_front = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
						}
						break;
					}
				}

				while ( true )
				{
					tmpy++;
					if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * tmpy + xpos] )
					{
						tmpy--;
						if ( 180 == orientation )
						{
							FieldRange_front = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
						}
						break;
					}
				}
			}

			if ( 90 == orientation || 270 == orientation ) // Ost & West Ausrichtung
			{
				while ( true )
				{
					tmpx--;
					if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * ypos + tmpx] )
					{
						xpos++;
						if (270 == orientation )
						{
							FieldRange_front = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
						}
						break;
					}

				}

				while ( true )
				{
					tmpx++;
					if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * ypos + tmpx] )
					{
						xpos--;
						if ( 90 == orientation )
						{
							FieldRange_front = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
						}
						break;
					}

				}

			}

			// Idea:
			// Check if it is an expected Wall. If not throw stop event. If expected than do nothing
			if ( CU_CriticalDistance < ( FieldRange_front * GLOBAL_1_SEKTOR ) )
			{
				throw stop_event;
				short iDriftdegree = CU_Drift();
				
				//search possible wall on map;
				
				
				
				//tell MotorUNit how to adjust;
				
				
				delete stop_event;
			}
			*/
			
			CU_PosCalibration(xpos, ypos, orientation);
		}
	}
}

unsigned short CU_CalibCompassValue( short orientation, short Offset )
{
	int help = orientation + Offset;

	if ( 360 <= help )
		help -= 360;

	if ( 0 > help )
		help += 360;

	return help;
}

short CU_GetAzimuthPositive( short degree )
{
	if ( degree < SU_Values.iCurrentDeg)
		return SU_Values.iCurrentDeg - degree;
	if ( degree > SU_Values.iCurrentDeg)
		return degree + SU_Values.iCurrentDeg;
}

short CU_GetAzimuth( short degree )
{
	short tmpdeg = degree - SU_Values.iCurrentDeg;

	if ( 180 < tmpdeg )
		tmpdeg -= 360;

	return tmpdeg;
}

void CU_Measuring_front( byte FieldRange_front )
{
		// Pruefen ob Hindernis in Reichweite ist
		if ( ( FieldRange_front * GLOBAL_1_SEKTOR ) >= SU_SONIC_RADIUS )
		{
			until(!MutexUSonic);
			SU_Values.iDistance_Front = SensorUS ( SU_SONIC_FRONT );


			// Verarbeitung Starten (Bedenken: Wird Rueckgabewert bedingt? Wenn ja, diese Funktion trennen, wegen Rueckgabewerte
			if ( SU_Values.iDistance_Front < ( FieldRange_front * GLOBAL_1_SEKTOR ) )
			{
				// Zu weit vorne 
				MU_drive_backward( ( FieldRange_front * GLOBAL_1_SEKTOR ) - SU_Values.iDistance_Front );
			}
			else if ( SU_Values.iDistance_Front > ( FieldRange_front * GLOBAL_1_SEKTOR ) )
			{
				// Zu weit hinten

				MU_drive_forward(  SU_Values.iDistance_Front - ( FieldRange_front * GLOBAL_1_SEKTOR ) );
			}
		}
}

void CU_Measuring_rear( byte FieldRange_rear)
{
		if ( ( FieldRange_rear * GLOBAL_1_SEKTOR ) >= SU_SONIC_RADIUS )
		{
			until(!MutexUSonic);
			SU_Values.iDistance_Back = SensorUS ( SU_SONIC_BACK );

			if ( SU_Values.iDistance_Back > ( FieldRange_rear * GLOBAL_1_SEKTOR ) )
			{
				// Zu weit vorne 
				MU_drive_backward( ( FieldRange_rear * GLOBAL_1_SEKTOR ) - SU_Values.iDistance_Front );
			}
			else if ( SU_Values.iDistance_Back < ( FieldRange_rear * GLOBAL_1_SEKTOR ) )
			{
				// Zu weit hinten
				MU_drive_forward( SU_Values.iDistance_Back - ( FieldRange_rear * GLOBAL_1_SEKTOR ) );
			}
		}
}

void CU_TurnToOrientation( short orientation )
{
		unsigned short degree = CU_CalibCompassValue( orientation, SU_InitCompassValue );

		if ( degree != SU_Values.iCurrentDeg )
		{
			short degreetoturn = CU_GetAzimuth( degree );

			MU_drehen_by_angle( degreetoturn );
		}
}

void CU_Drift( short orientation, byte xpos, byte ypos )
{
	if ( ( -1 != CU_TempCompassRef )  )
	{
		short iDiff = CU_GetAzimuthPositive( CU_TempCompassRef );
		if ( 80 > iDiff )
		{
			short side = CU_GetAzimuth( CU_TempCompassRef ) * (  -1 );

			CU_TurnToOrientation( orientation );
			// Etz steng ma wieda in da richtign Richtung
			
			short neworientation = 0;
			
			flag = 1;
			
			// Left
			if ( 0 > side )
			{
				// rechts drahn
				neworientation = CU_CalibCompassValue(orientation, 90);
			}
			else if ( 0 < side )	// Right
			{
				// links drahn
				neworientation = CU_CalibCompassValue(orientation, -90);
			}
			
			CU_TurnToOrientation ( neworientation );
			
			// zruck ind fahrrinna
			CU_PosCalibration( neworientation, xpos, ypos ); 
			
			// zruck drahn
			CU_TurnToOrientation ( orientation );
		}
	}
}

void CU_PosCalibration( byte xpos, byte ypos, short orientation )
{
    byte tmpx = xpos;
	byte tmpy = ypos;
	byte FieldRange_front = 0;
	byte FieldRange_rear = 0;

	if (flag == 0)
		CU_Drift( orientation, xpos, ypos );	// korrigiert die Position des Roboters senkrecht zur Fahrtrichtung zurück in die Fahrrinne
	flag = 0;

	if ( 0 == orientation || 180 == orientation ) // Nord & Sued Ausrichtung
	{
		while ( true )
		{
			tmpy--;
			if ( g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * tmpy + xpos] == '#')
			{
				tmpy++;
				if ( 0 == orientation )
				{
					FieldRange_front = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
				}
				else if ( 180 == orientation )
				{
					FieldRange_rear = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
				}
				break;
			}
		}

		while ( true )
		{
			tmpy++;
			if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * tmpy + xpos] )
			{
				tmpy--;
				if ( 0 == orientation )
				{
					FieldRange_rear = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
				}
				else if ( 180 == orientation )
				{
					FieldRange_front = ( ypos - tmpy ); // * GLOBAL_1_SEKTOR;
				}
				break;
			}
		}
	}

	if ( 90 == orientation || 270 == orientation ) // Ost & West Ausrichtung
	{
		while ( true )
		{
			tmpx--;
			if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * ypos + tmpx] )
			{
				xpos++;
				if ( 90 == orientation )
				{
					FieldRange_rear = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
				}
				else if (270 == orientation )
				{
					FieldRange_front = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
				}
				break;
			}

		}

		while ( true )
		{
			tmpx++;
			if ( '#' == g_MapModule_WorkField.map[GLOBAL_MAP_WIDTH * ypos + tmpx] )
			{
				xpos--;
				if ( 90 == orientation )
				{
					FieldRange_front = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
				}
				else if ( 270 == orientation )
				{
					FieldRange_rear = ( xpos - tmpx ); // * GLOBAL_1_SEKTOR;
				}
				break;
			}

		}

	}

	CU_Measuring_front( FieldRange_front );
	CU_Measuring_rear( FieldRange_rear );

	CU_TempCompassRef = SU_Values.iCurrentDeg;
}

#endif /* __CALIB_MODULE__ */